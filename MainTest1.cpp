#include "Particle.h"
#include "ParticleType.h"
#include "ResonanceType.h"
#include <cmath>
#include <iostream>

#include "TFile.h"
#include "TH1F.h"
#include "TMath.h"
#include "TRandom.h"
#include "TCanvas.h"

R__LOAD_LIBRARY(ParticleType_cpp.so)
R__LOAD_LIBRARY(ResonanceType_cpp.so)
R__LOAD_LIBRARY(Particle_cpp.so)

  
int main() {
  /*ParticleType *test[2];
  test[0] = new ParticleType("elettrone", 4.2, 1);
  test[1] = new ResonanceType("protone", 5.4, 2, 22.3);
  for (int i = 0; i < 2; i++)
    test[i]->Print();

  return 0;*/

  /*-----------------------------------------------------------------------------------------------*/
  // parte 2

  Particle::AddParticleType("Pion+", 0.13957, 1);
  Particle::AddParticleType("Pion-", 0.13957, -1);
  Particle::AddParticleType("Kaon+", 0.49367, 1);
  Particle::AddParticleType("Kaon-", 0.49367, -1);
  Particle::AddParticleType("Proton+", 0.93827, 1);
  Particle::AddParticleType("Proton-", 0.93827, -1);
  Particle::AddParticleType("K*", 0.89166, 0, 0.050);
  

  TH1D *h_ParticleType =
      new TH1D("h_ParticleType", "Particle Types", Particle::GetNParticleType(),
               0, Particle::GetNParticleType());
  TH1D *h_Theta = new TH1D("h_Theta", "Azimuth Angles", 1000, 0, M_PI);
  TH1D *h_Phi = new TH1D("h_Phi", "Polar Angles", 1000, 0, 2 * M_PI);
  TH1D *h_Momentum = new TH1D("h_Momentum", "Particle Momentum", 1000, 0, 5);
  TH1D *h_TrasversMomentum =
      new TH1D("h_TrasversMomentum", "Trasversal Momentum", 1000, 0, 5);
  TH1D *h_Energy = new TH1D("h_Energy", "Particle Energy", 1000, 0, 2);
  TH1D *h_InvariantMass = new TH1D(
      "h_InvariantMass", "Invariant Mass between all particles", 1000, 0, 2);

  TH1D *h_InvMassDiscordant = new TH1D(
      "h_InvMassDiscordant",
      "Invariant Mass between particles with opposite charges", 1000, 0, 2);
  TH1D *h_InvMassConcordant = new TH1D(
      "h_InvMassConcordant",
      "Invariant Mass between particles with equal charges", 1000, 0, 2);
  TH1D *h_DiscordantPiK =
      new TH1D("h_DiscordantPiK",
               "Invariant Mass between pions and kaons with opposite charges",
               1000, 0, 2);
  TH1D *h_ConcordantPiK = new TH1D(
      "h_ConcordantPiK",
      "Invariant Mass between pions and kaons with equal charges", 1000, 0, 2);
  TH1D *h_DecayMass = new TH1D(
      "h_DecayMass", "Invariant Mass between particles generated by K* decay",
      1000, 0, 5);

  h_InvariantMass->Sumw2();
  h_InvMassConcordant->Sumw2();
  h_InvMassDiscordant->Sumw2();
  h_DiscordantPiK->Sumw2();
  h_ConcordantPiK->Sumw2();
  h_DecayMass->Sumw2();

  gRandom->SetSeed();


  for (int i = 0; i < 1E5; i++) {

    int N = 120;
    Particle particle[N];
    int DecayCounter = 0;

    for (int j = 0; j < 100; j++) {

      double phi = gRandom->TRandom::Uniform(0, 2 * M_PI);
      double theta = gRandom->TRandom::Uniform(0, M_PI);
      double P = gRandom->TRandom::Exp(1);
      double px = P * sin(phi) * sin(theta);
      double py = P * cos(phi) * sin(theta);
      double pz = P * cos(theta);
      particle[j].SetP(px, py, pz);

      double x = gRandom->Rndm();

      if (x < 0.4) {
        particle[j].Particle::SetIndex("Pion+");

      } else if (x < 0.8) {
        particle[j].Particle::SetIndex("Pion-");

      } else if (x < 0.85) {
        particle[j].Particle::SetIndex("Kaon+");

      } else if (x < 0.9) {
        particle[j].Particle::SetIndex("Kaon-");

      } else if (x < 0.945) {
        particle[j].Particle::SetIndex("Proton+");

      } else if (x < 0.99) {
        particle[j].Particle::SetIndex("Proton-");

      } else {
        particle[j].Particle::SetIndex("K*");
        double y = gRandom->Rndm();

        Particle pion("Pion+", 0., 0., 0.);
        Particle kaon("Kaon-", 0., 0., 0.);

        if (y < 0.5) {
          pion.SetIndex("Pion-");
          kaon.SetIndex("Kaon+");
        }
        int v = particle[j].Particle::Decay2body(pion, kaon);

        particle[(50 + DecayCounter) * 2] = pion;
        particle[(50 + DecayCounter) * 2 + 1] = kaon;

        h_DecayMass->Fill(pion.InvMass(kaon));

        ++DecayCounter;
      }

      

      h_ParticleType->Fill(particle[j].GetIndex());
      h_Theta->Fill(theta);
      h_Phi->Fill(phi);
      h_Momentum->Fill(P);
      h_TrasversMomentum->Fill(sqrt(px * px + py * py));
      h_Energy->Fill(particle[j].GetEnergy());

    } // fine ciclo for interno j

    Particle pion1("Pion+", 0., 0., 0.);
    Particle pion2("Pion-", 0., 0., 0.);
    Particle kaon1("Kaon+", 0., 0., 0.);
    Particle kaon2("Kaon-", 0., 0., 0.);

    for (int p = 0; p < 100 + 2 * DecayCounter; ++p) {
      for (int q = 0; q < p; ++q) {
        Particle p1 = particle[p];
        Particle &p2 = particle[q];

        h_InvariantMass->Fill(p1.InvMass(p2));

        if (p1.GetCharge() * p2.GetCharge() > 0) {
          h_InvMassConcordant->Fill(p1.InvMass(p2));
        } else if (p1.GetCharge() * p2.GetCharge() < 0) {
          h_InvMassDiscordant->Fill(p1.InvMass(p2));
        }

        if (p1.GetIndex() == pion1.GetIndex()) {
          if (p2.GetIndex() == kaon1.GetIndex()) {
            h_ConcordantPiK->Fill(p1.InvMass(p2));
          } else if (p2.GetIndex() == kaon2.GetIndex()) {
            h_DiscordantPiK->Fill(p1.InvMass(p2));
          }
        } else if (p1.GetIndex() == pion2.GetIndex()) {
          if (p2.GetIndex() == kaon2.GetIndex()) {
            h_ConcordantPiK->Fill(p1.InvMass(p2));
          } else if (p2.GetIndex() == kaon1.GetIndex()) {
            h_DiscordantPiK->Fill(p1.InvMass(p2));
          }
        } else if (p1.GetIndex() == kaon1.GetIndex()) {
          if (p2.GetIndex() == pion1.GetIndex()) {
            h_ConcordantPiK->Fill(p1.InvMass(p2));
          } else if (p2.GetIndex() == pion2.GetIndex()) {
            h_DiscordantPiK->Fill(p1.InvMass(p2));
          }
        } else if (p1.GetIndex() == kaon2.GetIndex()) {
          if (p2.GetIndex() == pion2.GetIndex()) {
            h_ConcordantPiK->Fill(p1.InvMass(p2));
          } else if (p2.GetIndex() == pion1.GetIndex()) {
            h_DiscordantPiK->Fill(p1.InvMass(p2));
          }
        }
      }
    }

  } // fine ciclo for esterno i

  std::cout<<"fine generazione"<<'\n';

  // scrittura su file root per successiva anlisi
  TCanvas *canvas = new TCanvas("canvas","Canvas",10,20,500,600);
  canvas->Divide(4,3);

  canvas->cd(1);
  h_ParticleType->Draw("HISTO");
  canvas->cd(2);
  h_Phi->Draw("HISTO");
  canvas->cd(3);
  h_Theta->Draw("HISTO");
  canvas->cd(4);
  h_Momentum->Draw("HISTO");
  canvas->cd(5);
  h_TrasversMomentum->Draw("HISTO");
  canvas->cd(6);
  h_Energy->Draw("HISTO");
  canvas->cd(7);
  h_InvariantMass->Draw("HISTO");
  canvas->cd(8);
  h_InvMassConcordant->Draw("HISTO");
  canvas->cd(9);
  h_InvMassDiscordant->Draw("HISTO");
  canvas->cd(10);
  h_ConcordantPiK->Draw("HISTO");
  canvas->cd(11);
  h_DiscordantPiK->Draw("HISTO");
  canvas->cd(12);
  h_DecayMass->Draw("HISTO");


  TCanvas *canvas2 = new TCanvas("canvas2","Canvas2",10,20,500,600);
  h_DecayMass->Draw("HISTO");
  
  TFile *particleRootFile = new TFile("paricleRootFile", "RECREATE");
  particleRootFile->Write();
  particleRootFile->Close();

} // int main
