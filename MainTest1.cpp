#include "Particle.h"
#include "ParticleType.h"
#include "ResonanceType.h"
#include <cmath>
#include <iostream>

#include "TCanvas.h"
#include "TFile.h"
#include "TH1F.h"
#include "TMath.h"
#include "TRandom.h"
#include "TStyle.h"


R__LOAD_LIBRARY(ParticleType_cpp.so)
R__LOAD_LIBRARY(ResonanceType_cpp.so)
R__LOAD_LIBRARY(Particle_cpp.so)

int main() {

  gStyle->SetOptStat("e");
  gStyle->SetOptFit(1);
  gStyle->SetFitFormat("7.6g");

  Particle::AddParticleType("Pion+", 0.13957, 1);
  Particle::AddParticleType("Pion-", 0.13957, -1);
  Particle::AddParticleType("Kaon+", 0.49367, 1);
  Particle::AddParticleType("Kaon-", 0.49367, -1);
  Particle::AddParticleType("Proton+", 0.93827, 1);
  Particle::AddParticleType("Proton-", 0.93827, -1);
  Particle::AddParticleType("K*", 0.89166, 0, 0.050);

  TH1D *h_ParticleType =
      new TH1D("h_ParticleType", "Particle Types", Particle::GetNParticleType(),
               0, Particle::GetNParticleType());
  TH1D *h_Theta = new TH1D("h_Theta", "Azimuth Angles", 1000, 0, M_PI);
  TH1D *h_Phi = new TH1D("h_Phi", "Polar Angles", 1000, 0, 2 * M_PI);
  TH1D *h_Momentum = new TH1D("h_Momentum", "Particle Momentum", 1000, 0, 5);
  TH1D *h_TrasversMomentum =
      new TH1D("h_TrasversMomentum", "Trasversal Momentum", 1000, 0, 5);
  TH1D *h_Energy = new TH1D("h_Energy", "Particle Energy", 1000, 0, 5);
  TH1D *h_InvariantMass = new TH1D(
      "h_InvariantMass", "Invariant Mass between all particles", 1000, 0, 5);

  TH1D *h_InvMassDiscordant = new TH1D(
      "h_InvMassDiscordant",
      "Invariant Mass between particles with opposite charges", 1000, 0, 5);
  TH1D *h_InvMassConcordant = new TH1D(
      "h_InvMassConcordant",
      "Invariant Mass between particles with equal charges", 1000, 0, 5);
  TH1D *h_DiscordantPiK =
      new TH1D("h_DiscordantPiK",
               "Invariant Mass between pions and kaons with opposite charges",
               1000, 0, 5);
  TH1D *h_ConcordantPiK = new TH1D(
      "h_ConcordantPiK",
      "Invariant Mass between pions and kaons with equal charges", 1000, 0, 5);
  TH1D *h_DecayMass = new TH1D(
      "h_DecayMass", "Invariant Mass between particles generated by K* decay",
      1000, 0, 1.5);

  h_ParticleType->GetXaxis()->SetBinLabel(1, "Pions +");
  h_ParticleType->GetXaxis()->SetBinLabel(2, "Pions -");
  h_ParticleType->GetXaxis()->SetBinLabel(3, "Kaons +");
  h_ParticleType->GetXaxis()->SetBinLabel(4, "Kaons -");
  h_ParticleType->GetXaxis()->SetBinLabel(5, "Protons +");
  h_ParticleType->GetXaxis()->SetBinLabel(6, "Protons -");
  h_ParticleType->GetXaxis()->SetBinLabel(7, "K*");

  h_ParticleType->SetXTitle("Particle Type");
  h_ParticleType->SetYTitle("Occurrences");
  h_Theta->SetXTitle("Theta [Rad]");
  h_Theta->SetYTitle("Occurrences");
  h_Phi->SetXTitle("Phi [Rad]");
  h_Phi->SetYTitle("Occurrences");
  h_Momentum->SetXTitle("P [GeV]");
  h_Momentum->SetYTitle("Occurrences");
  h_TrasversMomentum->SetXTitle("Trasversal Momentum [GeV]");
  h_TrasversMomentum->SetYTitle("Occurrences");
  h_Energy->SetXTitle("Energy [GeV]");
  h_Energy->SetYTitle("Occurrences");
  h_InvariantMass->SetXTitle("Mass [GeV/C^2]");
  h_InvariantMass->SetYTitle("Occurrences");
  h_InvMassDiscordant->SetXTitle("Mass [GeV/C^2]");
  h_InvMassDiscordant->SetYTitle("Occurrences");
  h_InvMassConcordant->SetXTitle("Mass [GeV/C^2]");
  h_InvMassConcordant->SetYTitle("Occurrences");
  h_ConcordantPiK->SetXTitle("Mass [GeV/C^2]");
  h_ConcordantPiK->SetYTitle("Occurrences");
  h_DiscordantPiK->SetXTitle("Mass [GeV/C^2]");
  h_DiscordantPiK->SetYTitle("Occurrences");
  h_DecayMass->SetXTitle("Mass [GeV/C^2]");
  h_DecayMass->SetYTitle("Occurrences");

  h_InvariantMass->Sumw2();
  h_InvMassConcordant->Sumw2();
  h_InvMassDiscordant->Sumw2();
  h_DiscordantPiK->Sumw2();
  h_ConcordantPiK->Sumw2();
  h_DecayMass->Sumw2();

  gRandom->SetSeed();

  for (int i = 0; i < 1E5; i++) { 

    int N = 120;
    Particle particle[N];
    int DecayCounter = 0;

    for (int j = 0; j < 100; j++) {

      double phi = gRandom->TRandom::Uniform(0, 2 * M_PI);
      double theta = gRandom->TRandom::Uniform(0, M_PI);
      double P = gRandom->TRandom::Exp(1);
      double px = P * sin(phi) * sin(theta);
      double py = P * cos(phi) * sin(theta);
      double pz = P * cos(theta);
      particle[j].SetP(px, py, pz);

      double x = gRandom->Rndm();

      if (x < 0.4) {
        particle[j].Particle::SetIndex("Pion+");

      } else if (x < 0.8) {
        particle[j].Particle::SetIndex("Pion-");

      } else if (x < 0.85) {
        particle[j].Particle::SetIndex("Kaon+");

      } else if (x < 0.9) {
        particle[j].Particle::SetIndex("Kaon-");

      } else if (x < 0.945) {
        particle[j].Particle::SetIndex("Proton+");

      } else if (x < 0.99) {
        particle[j].Particle::SetIndex("Proton-");

      } else {
        particle[j].Particle::SetIndex("K*");
        double y = gRandom->Rndm();

        Particle pion("Pion+", 0., 0., 0.);
        Particle kaon("Kaon-", 0., 0., 0.);

        if (y < 0.5) {
          pion.SetIndex("Pion-");
          kaon.SetIndex("Kaon+");
        }
        int v = particle[j].Particle::Decay2body(pion, kaon);

        particle[(50 + DecayCounter) * 2] = pion;
        particle[(50 + DecayCounter) * 2 + 1] = kaon;

        h_DecayMass->Fill(pion.InvMass(kaon));

        ++DecayCounter;
      }

      h_ParticleType->Fill(particle[j].GetIndex());
      h_Theta->Fill(theta);
      h_Phi->Fill(phi);
      h_Momentum->Fill(P);
      h_TrasversMomentum->Fill(sqrt(px * px + py * py));
      h_Energy->Fill(particle[j].GetEnergy());

    } // fine ciclo for interno j

    Particle pion1("Pion+", 0., 0., 0.);
    Particle pion2("Pion-", 0., 0., 0.);
    Particle kaon1("Kaon+", 0., 0., 0.);
    Particle kaon2("Kaon-", 0., 0., 0.);

    for (int p = 0; p < 100 + 2 * DecayCounter; ++p) {
      for (int q = 0; q < p; ++q) {
        Particle p1 = particle[p];
        Particle &p2 = particle[q];

        h_InvariantMass->Fill(p1.InvMass(p2));

        if (p1.GetCharge() * p2.GetCharge() > 0) {
          h_InvMassConcordant->Fill(p1.InvMass(p2));
        } else if (p1.GetCharge() * p2.GetCharge() < 0) {
          h_InvMassDiscordant->Fill(p1.InvMass(p2));
        }

        if (p1.GetIndex() == pion1.GetIndex()) {
          if (p2.GetIndex() == kaon1.GetIndex()) {
            h_ConcordantPiK->Fill(p1.InvMass(p2));
          } else if (p2.GetIndex() == kaon2.GetIndex()) {
            h_DiscordantPiK->Fill(p1.InvMass(p2));
          }
        } else if (p1.GetIndex() == pion2.GetIndex()) {
          if (p2.GetIndex() == kaon2.GetIndex()) {
            h_ConcordantPiK->Fill(p1.InvMass(p2));
          } else if (p2.GetIndex() == kaon1.GetIndex()) {
            h_DiscordantPiK->Fill(p1.InvMass(p2));
          }
        } else if (p1.GetIndex() == kaon1.GetIndex()) {
          if (p2.GetIndex() == pion1.GetIndex()) {
            h_ConcordantPiK->Fill(p1.InvMass(p2));
          } else if (p2.GetIndex() == pion2.GetIndex()) {
            h_DiscordantPiK->Fill(p1.InvMass(p2));
          }
        } else if (p1.GetIndex() == kaon2.GetIndex()) {
          if (p2.GetIndex() == pion2.GetIndex()) {
            h_ConcordantPiK->Fill(p1.InvMass(p2));
          } else if (p2.GetIndex() == pion1.GetIndex()) {
            h_DiscordantPiK->Fill(p1.InvMass(p2));
          }
        }
      }
    }

  } // fine ciclo for esterno i

  std::cout << "fine generazione" << '\n';

  TCanvas *canvas = new TCanvas("canvas", "Canvas", 10, 20, 1200, 650);
  canvas->Divide(4, 3);

  canvas->cd(1);
  h_ParticleType->Draw();
  canvas->cd(2);
  h_Phi->Draw();
  canvas->cd(3);
  h_Theta->Draw();
  canvas->cd(4);
  h_Momentum->Draw();
  canvas->cd(5);
  h_TrasversMomentum->Draw();
  canvas->cd(6);
  h_Energy->Draw();
  canvas->cd(7);
  h_InvariantMass->Draw();
  canvas->cd(8);
  h_InvMassConcordant->Draw();
  canvas->cd(9);
  h_InvMassDiscordant->Draw();
  canvas->cd(10);
  h_ConcordantPiK->Draw();
  canvas->cd(11);
  h_DiscordantPiK->Draw();
  canvas->cd(12);
  h_DecayMass->Draw();

  //analisi--------------------------------------------------------------------------------------------------------  
  
  std::cout << "Pions+:" << h_ParticleType->GetBinContent(1) << "+/-"
            << h_ParticleType->GetBinError(1) << "\n"
            << "Pions-:" << h_ParticleType->GetBinContent(2) << "+/-"
            << h_ParticleType->GetBinError(2) << "\n"
            << "Kaone+:" << h_ParticleType->GetBinContent(3) << "+/-"
            << h_ParticleType->GetBinError(3) << "\n"
            << "Kaons-:" << h_ParticleType->GetBinContent(4) << "+/-"
            << h_ParticleType->GetBinError(4) << "\n"
            << "Protons+:" << h_ParticleType->GetBinContent(5) << "+/-"
            << h_ParticleType->GetBinError(5) << "\n"
            << "Protons-:" << h_ParticleType->GetBinContent(6) << "+/-"
            << h_ParticleType->GetBinError(7) << "\n"
            << "K*" << h_ParticleType->GetBinContent(7) << "+/-"
            << h_ParticleType->GetBinError(7) << "\n";
  
  
  TCanvas *c_distribution = new TCanvas("Distributions", "Distributions", 1200, 650);
  c_distribution->Divide(2, 2);

  c_distribution->cd(1);
  h_ParticleType->DrawCopy();

  c_distribution->cd(2);
  h_Momentum->Fit("expo", "Q");
  h_Momentum->DrawCopy();

  c_distribution->cd(3);
  h_Theta->Fit("pol0");
  h_Theta->DrawCopy();

  c_distribution->cd(4);
  h_Phi->Fit("pol0");
  h_Phi->DrawCopy();

  TCanvas *c_mass = new TCanvas("K* Masses Analysis", "K* Masses Analysis", 1200, 650);
  c_mass->Divide(2, 2);

  TH1D *h_Subtraction = new TH1D("h_Subtraction",
                                 "Subtraction of invariant mass of K and P "
                                 "with concordant and discordant charge",
                                 1000, 0, 5);
  c_mass->cd(1);
  h_DecayMass->Fit("gaus");
  h_DecayMass->SetAxisRange(0.6, 1.2);
  h_DecayMass->DrawCopy();

  c_mass->cd(2);
  h_Subtraction->Add(h_DiscordantPiK, h_ConcordantPiK, 1, -1);
  h_Subtraction->Fit("gaus", "B", "", 0.5, 1.5);
  h_Subtraction->SetAxisRange(0.65, 1.2);
  h_Subtraction->SetXTitle("Mass [GeV/C^2]");
  h_Subtraction->SetYTitle("Occurrences");
  h_Subtraction->DrawCopy();

  TH1D *h_Subtraction2 = new TH1D("h_Subtraction2",
                                  "Subtraction of invariant mass of particles "
                                  "with concordant and discordant charge",
                                  1000, 0, 5);

  c_mass->cd(3);
  h_Subtraction2->Add(h_InvMassDiscordant, h_InvMassConcordant, 1, -1);
  h_Subtraction2->Fit("gaus", "B", "", 0.5, 1.5);
  h_Subtraction2->SetAxisRange(0.65, 1.2);
  h_Subtraction->SetXTitle("Mass [GeV/C^2]");
  h_Subtraction->SetYTitle("Occurrences");
  h_Subtraction2->DrawCopy();

  c_mass->Print("Comparison.png");
  c_distribution->Print("Distributions.png");

  //--------------------------------------------------------------------------------------------------------

  TFile *particleRootFile = new TFile("paricleRootFile.root", "RECREATE");
  particleRootFile->cd();

  h_ParticleType->Write();
  h_Phi->Write();
  h_Theta->Write();
  h_Momentum->Write();
  h_TrasversMomentum->Write();
  h_Energy->Write();
  h_InvariantMass->Write();
  h_InvMassConcordant->Write();
  h_InvMassDiscordant->Write();
  h_ConcordantPiK->Write();
  h_DiscordantPiK->Write();
  h_DecayMass->Write();
  

  particleRootFile->Close();

  

} // int main
